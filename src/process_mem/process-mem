#!/usr/bin/python
"""
Display memory usage for process(es)
"""
import getpass
import argparse
import textwrap
from typing import Optional
from pydantic import BaseModel
import psutil

def help_epilog():
    """ add to help listing """
    epilog = textwrap.dedent('''\
            Input
              Determines which processes are included.
              User can be any user or :all: for all users. Current user by default.
              Process Names limit the output to those processes.
                If none provided, then all processes are included that match user.

            Output
              1 row per process with each row :
                name : [num] rss vms shr
                    name is name of process
                    rss is resident set size
                    vms is virtual memory size
                    shr is memory (potentially) shared with other processes
                    slib is shared library memory (full report)
                    dirty is the number of dirty pages (full report)
             ''')
    return epilog

class MemInfo(BaseModel):
    """ process memory data """
    name: str = ''
    num: int = 0
    rss: int = 0
    vms: int = 0
    shared: int = 0
    slib: Optional[int] = 0
    dirty: Optional[int] = 0

    def add(self, num:int, rss:int, vms:int, shared:int, slib:int=0, dirty:int=0):
        """
        increment the counters for each process
        """
        # pylint: disable=too-many-arguments,too-many-positional-arguments
        self.num += num
        self.rss += rss
        self.vms += vms
        self.shared += shared
        self.slib += slib
        self.dirty += dirty

    def text_units(self):
        """
        return dictionary with each item as text with human units
        """
        info = {'num': number2metric(self.num),
                'rss': bytes2human(self.rss),
                'vms': bytes2human(self.vms),
                'shared': bytes2human(self.shared),
                'slib': bytes2human(self.slib),
                'dirty': number2metric(self.dirty),
               }
        return info

def bytes2human(byts):
    """
    Map Bytes to human units
      - K, G, etc
    """
    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {}

    # prefix = 1024, 1024^2, 1024^3 ...
    for i, s in enumerate(symbols):
        prefix[s] = 1 << (i + 1) * 10

    # work from largest to smallest unit
    for s in reversed(symbols):
        if abs(byts) >= prefix[s]:
            value = float(byts) / prefix[s]
            return f'{value:.1f}{s}'
    return f'{byts}B'

def number2metric(num):
    """
    Map number to SI (metric)
      - k, g, etc
    """
    symbols = ('k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {
            'k' : 1000,
            'M' : 1000_000,
            'G' : 1000_000_000,
            'T' : 1000_000_000_000,
            'P' : 1000_000_000_000_000,
            'E' : 1000_000_000_000_000_000,
            'Z' : 1000_000_000_000_000_000_000,
            'Y' : 1000_000_000_000_000_000_000_000,
            }

    # work from largest to smallest unit
    for s in reversed(symbols):
        if abs(num) >= prefix[s]:
            value = float(num) / prefix[s]
            return f'{value:.1f}{s}'
    return f'{num}'

class ProcInfo:
    """
    Mini class to get process info
    """
    def __init__(self):
        self.pnames = []
        self.current_user = getpass.getuser()
        self.user = self.current_user
        self.full = False

        epilog = help_epilog()
        par = argparse.ArgumentParser(description='Show Process(es) Memory', epilog=epilog,
                                      formatter_class=argparse.RawDescriptionHelpFormatter)

        ahelp = f'username or :all: default ({self.user})'
        par.add_argument('-u', '--user', default=self.user, help=ahelp)

        ahelp = f'Full report adds shared lib and dirty pages ({self.full})'
        par.add_argument('-f', '--full', help=ahelp, action='store_true', default=self.full)

        ahelp = 'process names to check (all processes if not provided)'
        par.add_argument('pnames', nargs='*', help=ahelp)

        parsed = par.parse_args()
        if parsed:
            for (opt, val) in vars(parsed).items():
                setattr(self, opt, val)

        if self.user != self.current_user:
            print(f'Checking process mem for: {self.user}')

    def show_info(self):
        """
        Pull info matching user and pnames
        """
        summary = self.proc_mem_info()
        if not summary or len(summary) < 1:
            return

        show_total = False
        if len(summary) > 2:
            # length = num_proces names + total
            show_total = True

        hdr = f'{"Proc-Name":>28s} : [num] {"rss":>8s} {"vsz":>8s} {"shr":>8s}'
        if self.full:
            hdr += f' {"slib":>8s} {"dirty":>8s}'
        print(hdr)
        for mem in summary:
            name = mem.name
            info = mem.text_units()

            row = f'[{info['num']:>3s}] {info['rss']:>8s} {info['vms']:>8s} {info['shared']:>8s}'
            if self.full:
                row += f' {info['slib']:>8s} {info['dirty']:>8}'

            if mem.name != 'Total' or show_total :
                print(f'{name:>28s} : {row}')

    def proc_mem_info(self) -> [MemInfo] :
        """
        Retrieve meminfo about each process in pnames
        """
        #
        # Gather the info
        #
        proc_info = {}
        for proc in psutil.process_iter(['pid', 'username', 'name', 'memory_info']):
            pname = proc.info.get('name')

            if not self._keep_filter(proc):
                continue

            if not proc_info.get(pname):
                proc_info[pname] = []

            #
            # pmem ~ pmem.rss. pmem.vms, pmem.shared
            #
            pmem = proc.info['memory_info']
            proc_info[pname].append(pmem)

        #
        # Summarize
        #
        summary = []
        mem_tot = MemInfo(name='Total')
        for (name, pmems) in proc_info.items():
            num = len(pmems)
            mem_info = MemInfo(name=name)
            for pmem in pmems:
                mem_info.add(1, pmem.rss, pmem.vms, pmem.shared, pmem.lib, pmem.dirty)

            summary.append(mem_info)
            mem_tot.add(num, mem_info.rss, mem_info.vms, mem_info.shared, mem_info.slib, mem_info.dirty)
        summary.append(mem_tot)

        return summary

    def _keep_filter(self, proc) :
        """
        return true if this proc is to be kept
        """
        proc_user = proc.info.get('username')
        if self.user not in (':all:', proc_user):
            return False

        proc_name = proc.info.get('name')
        if not self.pnames or proc_name in self.pnames:
            return True
        return False

def main() :
    """
    Get process info for process(es)
     - input is process name(s)
    """

    proc_info = ProcInfo()
    proc_info.show_info()

if __name__ == '__main__':
    main()
